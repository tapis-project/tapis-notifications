package edu.utexas.tacc.tapis.notifications.service;

import edu.utexas.tacc.tapis.notifications.dao.NotificationsDao;
import edu.utexas.tacc.tapis.notifications.model.Delivery;
import edu.utexas.tacc.tapis.notifications.model.DeliveryMethod;
import edu.utexas.tacc.tapis.notifications.model.Event;
import edu.utexas.tacc.tapis.notifications.model.Notification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;

/*
 * Callable for sending out a single notification generated by a bucket manager.
 *
 */
public final class DeliveryWorker implements Callable<String>
{
  /* ********************************************************************** */
  /*                               Constants                                */
  /* ********************************************************************** */
  // Tracing.
  private static final Logger log = LoggerFactory.getLogger(DeliveryWorker.class);

//  public static final String VHOST = "NotificationsHost";
//  public static final String DEFAULT_BINDING_KEY = "#";
//  public static final String EXCHANGE_MAIN = "tapis.notifications.exchange";
//  public static final String QUEUE_MAIN = "tapis.notifications.queue";

  /* ********************************************************************** */
  /*                                Enums                                   */
  /* ********************************************************************** */

  /* ********************************************************************** */
  /*                                 Fields                                 */
  /* ********************************************************************** */

  // Use HK2 to inject singletons
  @Inject
  private NotificationsDao dao;

  private final int bucketNum;
  private final int workerNum;
  private final String workerId;
  private final BlockingQueue<Notification> deliveryWorkerQueue;

  /* ********************************************************************** */
  /*                             Constructors                               */
  /* ********************************************************************** */

  /*
   * Callable is associated with a specific worker in a specific bucket
   * deliveryWorkerQueues must be non-null and be large enough to have an entry at index workerNum.
   *
   * NOTE: bucketNum is for logging only. Here we only care about our workerNum because it tells us
   *       which workerQueue to use to get incoming notifications.
   */
  DeliveryWorker(List<BlockingQueue<Notification>> deliveryWorkerQueues1, int bucketNum1, int workerNum1)
  {
    // Check for invalid parameters.
    if (deliveryWorkerQueues1 == null || workerNum1+1 > deliveryWorkerQueues1.size())
    {
      throw new IllegalArgumentException("deliveryWorkerQueues was null or too small for workerNum: " + workerNum1);
    }
    bucketNum = bucketNum1;
    workerNum = workerNum1;
    workerId = String.format("%d:%d", bucketNum, workerNum);
    deliveryWorkerQueue = deliveryWorkerQueues1.get(workerNum1);
  }
  
  /* ********************************************************************** */
  /*                             Public Methods                             */
  /* ********************************************************************** */

  /*
   * Main method for thread.start
   */
  @Override
  public String call()
  {
    log.info("**** Starting Delivery Worker: {}", workerId);
    try { Thread.sleep(1000); } catch (InterruptedException e) {}

    // Wait for and process items until we are interrupted
    Notification notification;
    try
    {
      while (true)
      {
        notification = deliveryWorkerQueue.take();
        processNotification(notification);
      }
    }
    catch (IOException | InterruptedException e)
    {
      // TODO
      log.warn("Caught exception: " + e.getMessage(), e);
    }

    log.info("**** Stopping Delivery Worker: {}", workerId);
    return "Delivery worker shutdown: " + workerId;
  }


  /* ********************************************************************** */
  /*                             Accessors                                  */
  /* ********************************************************************** */

  public int getBucketNum() { return bucketNum; }
  public int getWorkerNum() { return workerNum; }
  public String getWorkerId() { return workerId; }

  /* ********************************************************************** */
  /*                             Private Methods                            */
  /* ********************************************************************** */

  private void processNotification(Notification notification) throws IOException
  {
    Event event = notification.getEvent();
    DeliveryMethod deliveryMethod = notification.getDeliveryMethod();
    log.info("Processing notification for event. Source: {} Type: {} Subject: {} SeriesId: {} Time: {} UUID {}",
             event.getSource(), event.getType(), event.getSubject(), event.getSeriesId(),
             event.getTime(), event.getUuid());
    log.info("TODO Deliver notification. DeliveryType: {} DeliveryAddress: {}", deliveryMethod.getDeliveryType(),
             deliveryMethod.getDeliveryAddress());
    try {log.info("Sleep 2 seconds"); Thread.sleep(2000); } catch (InterruptedException e) {};
  }
}