package edu.utexas.tacc.tapis.notifications.service;

import java.io.IOException;
import java.util.UUID;
import java.util.concurrent.Callable;
import javax.ws.rs.core.Response.Status;

import edu.utexas.tacc.tapis.notifications.model.DeliveryTarget;
import okhttp3.Call;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.utexas.tacc.tapis.shared.providers.email.EmailClient;
import edu.utexas.tacc.tapis.shared.providers.email.EmailClientFactory;
import edu.utexas.tacc.tapis.shared.utils.HTMLizer;
import edu.utexas.tacc.tapis.shared.utils.TapisGsonUtils;
import edu.utexas.tacc.tapis.shared.TapisConstants;
import edu.utexas.tacc.tapis.shared.exceptions.TapisException;
import edu.utexas.tacc.tapis.notifications.config.RuntimeParameters;
import edu.utexas.tacc.tapis.notifications.utils.LibUtils;
import edu.utexas.tacc.tapis.notifications.dao.NotificationsDao;
import edu.utexas.tacc.tapis.notifications.model.Event;
import edu.utexas.tacc.tapis.notifications.model.Notification;

/*
 * Callable for sending out a single notification generated by a bucket manager.
 * After finite number of attempts give up and add the notification to the recovery table.
 * Number of attempts determined by runtime setting TAPIS_NTF_DELIVERY_ATTEMPTS
 * Attempt interval determined by runtime setting TAPIS_NTF_DELIVERY_RETRY_INTERVAL
 */
public final class DeliveryTask implements Callable<Notification>
{
  /* ********************************************************************** */
  /*                               Constants                                */
  /* ********************************************************************** */
  // Tracing.
  private static final Logger log = LoggerFactory.getLogger(DeliveryTask.class);

  /* ********************************************************************** */
  /*                                Enums                                   */
  /* ********************************************************************** */

  /* ********************************************************************** */
  /*                                 Fields                                 */
  /* ********************************************************************** */

  private final NotificationsDao dao;
  private final Notification notification; // The notification to be processed
  private final String tenant;
  private final UUID uuid;
  private final int bucketNum; // Bucket that generated the notification
  private final DeliveryTarget deliveryTarget;
  private static final OkHttpClient httpClient = new OkHttpClient();

  /* ********************************************************************** */
  /*                             Constructors                               */
  /* ********************************************************************** */

  DeliveryTask(NotificationsDao dao1, Notification n1)
  {
    dao = dao1;
    notification = n1;
    tenant = n1.getTenant();
    bucketNum = n1.getBucketNum();
    deliveryTarget = n1.getDeliveryTarget();
    uuid = n1.getUuid();
  }

  /* ********************************************************************** */
  /*                             Public Methods                             */
  /* ********************************************************************** */

  /*
   * Main method for thread.start
   * Make multiple attempts to deliver the notification. Pause after each attempt.
   * Number of attempts and interval are based on runtime settings.
   */
  @Override
  public Notification call() throws InterruptedException
  {
    int bucketNum = notification.getBucketNum();
    DeliveryTarget deliveryTarget = notification.getDeliveryTarget();
    UUID uuid = notification.getUuid();

    Thread.currentThread().setName("ThreadDelivery-bucket-" + bucketNum + "-method-" + deliveryTarget);
    log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_START", bucketNum, Thread.currentThread().getId(), Thread.currentThread().getName()));

    // Get number of attempts and attempt interval from settings.
    int numAttempts = RuntimeParameters.getInstance().getNtfDeliveryMaxAttempts();
    long deliveryAttemptInterval = RuntimeParameters.getInstance().getNtfDeliveryRetryInterval() * 1000L;
    for (int i = 1; i <= numAttempts; i++)
    {
      log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_ATTEMPT", bucketNum, uuid, i, deliveryTarget));
      try
      {
        // Attempt to make the delivery
        boolean delivered = deliverNotification(notification);
        // If delivered ok we are done. Perform any post-delivery steps and return
        if (delivered) return notificationDelivered();

        // Delivery failed, log a warning.
        log.warn(LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL1", bucketNum, uuid, i, deliveryTarget));
      }
      catch (Exception e)
      {
        log.warn(LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL2", bucketNum, uuid, i, deliveryTarget, e.getMessage()), e);
      }
      // Pause for configured interval before trying again
      // NOTE: Do not catch InterruptedException. If interrupted we are shutting down and should not make another attempt.
      log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_ATTEMPT_PAUSE", bucketNum, uuid, i, deliveryAttemptInterval));
      Thread.sleep(deliveryAttemptInterval);
    }

    // Give up for now, log warning and add to recovery table
    String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL", bucketNum, notification.getUuid(),
                                 deliveryTarget.getDeliveryMethod(), deliveryTarget.getDeliveryAddress(), numAttempts);
    log.warn(msg);
    addNotificationToRecovery();
    return null;
  }

  // ====================================================================================
  //  Make the delivery methods public static so they can also be used by recovery task
  // ====================================================================================

  /*
   * Send out a notification via WEBHOOK or EMAIL
   */
  public static boolean deliverNotification(Notification notification) throws IOException, TapisException
  {
    int bucketNum = notification.getBucketNum();
    Event event = notification.getEvent();
    DeliveryTarget deliveryTarget =  notification.getDeliveryTarget();

    log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY", bucketNum, notification.getUuid(), deliveryTarget.getDeliveryMethod(),
            deliveryTarget.getDeliveryAddress(), event.getSource(), event.getType(),
            event.getSubject(), event.getData(), event.getSeriesId(), event.getTimestamp(), event.getUuid()));
    boolean deliveryStatus = false;
    switch (deliveryTarget.getDeliveryMethod())
    {
      case WEBHOOK -> deliveryStatus = deliverByWebhook(notification);
      case EMAIL -> deliveryStatus = deliverByEmail(notification);
    }
    return deliveryStatus;
  }

  /* ********************************************************************** */
  /*                             Private Methods                            */
  /* ********************************************************************** */

  /*
   * Send out the notification via Webhook
   * By default OkHttpClient has read and write timeouts of 1 second.
   */
  private static boolean deliverByWebhook(Notification ntf) throws IOException
  {
    boolean delivered = true;
    int bucketNum = ntf.getBucketNum();
    DeliveryTarget deliveryTarget =  ntf.getDeliveryTarget();
    // Body is the notification as json
    String notifJsonStr = TapisGsonUtils.getGson(true).toJson(ntf);

    // Build the request
    RequestBody body = RequestBody.create(notifJsonStr, MediaType.parse("application/json"));
    Request.Builder requestBuilder = new Request.Builder().url(deliveryTarget.getDeliveryAddress()).post(body);
    Request request = requestBuilder.addHeader("User-Agent", "Tapis/%s".formatted(TapisConstants.API_VERSION)).build();
    Call call = httpClient.newCall(request);
    // Use try-with-resources to auto-close the response.
    try (Response response = call.execute())
    {
      // If response status code is not 200 assume delivery failed.
      if (response.code() != Status.OK.getStatusCode())
      {
        log.error(LibUtils.getMsg("NTFLIB_DSP_DLVRY_WH_FAIL_ERR", bucketNum, ntf.getUuid(),
                deliveryTarget.getDeliveryMethod(), deliveryTarget.getDeliveryAddress(), response.code()));
        delivered = false;
      }
    }
    return delivered;
  }

  /*
   * Send out the notification via email
   */
  private static boolean deliverByEmail(Notification ntf) throws TapisException
  {
    boolean delivered = true;
    DeliveryTarget deliveryTarget =  ntf.getDeliveryTarget();
    // Body is the notification as json
    String notifJsonStr = TapisGsonUtils.getGson(true).toJson(ntf);

    String eventType = ntf.getEvent().getType();
    String eventSubj = ntf.getEvent().getSubject();
    String mailSubj;
    if (StringUtils.isBlank(eventSubj))
      mailSubj = LibUtils.getMsg("NTFLIB_DSP_DLVRY_MAIL_SUBJ1", TapisConstants.API_VERSION, eventType);
    else
      mailSubj = LibUtils.getMsg("NTFLIB_DSP_DLVRY_MAIL_SUBJ2", TapisConstants.API_VERSION, eventType, eventSubj);
    String mailBody = notifJsonStr;
    String sendToAddress = deliveryTarget.getDeliveryAddress();
    String sendToName = deliveryTarget.getDeliveryAddress();
    RuntimeParameters runtime = RuntimeParameters.getInstance();
    EmailClient client = EmailClientFactory.getClient(runtime);
    client.send(sendToName, sendToAddress, mailSubj, mailBody, HTMLizer.htmlize(mailBody));
    return delivered;
  }

  /*
   * Notification has been delivered. Remove all matching entries from the table.
   * Entries are considered matching based on (eventUuid, deliveryTarget)
   */
  private Notification notificationDelivered()
  {
    try { dao.deleteNotificationsByDeliveryTarget(tenant, notification); }
    catch (TapisException e)
    {
      String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_DEL_ERR", bucketNum, uuid,
                             deliveryTarget.getDeliveryMethod(), deliveryTarget.getDeliveryAddress(), e.getMessage(), e);
      log.error(msg);
      return null;
    }
    return notification;
  }

  /*
   * Initial Notification delivery failed. Add it to the recovery table and delete it from notification table
   *  in a single transaction.
   */
  private void addNotificationToRecovery()
  {
    try
    {
      dao.deleteNotificationAndAddToRecovery(tenant, notification);
    }
    catch (TapisException e)
    {
      String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_RCVR_ADD_ERR", bucketNum, notification.getUuid(),
                                   deliveryTarget.getDeliveryMethod(), deliveryTarget.getDeliveryAddress(),
                                   e.getMessage(), e);
      log.error(msg);
    }
  }
}