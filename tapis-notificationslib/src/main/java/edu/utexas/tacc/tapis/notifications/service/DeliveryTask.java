package edu.utexas.tacc.tapis.notifications.service;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.UUID;
import java.util.concurrent.Callable;
import javax.ws.rs.core.Response.Status;

import okhttp3.Call;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.utexas.tacc.tapis.shared.providers.email.EmailClient;
import edu.utexas.tacc.tapis.shared.providers.email.EmailClientFactory;
import edu.utexas.tacc.tapis.shared.utils.HTMLizer;
import edu.utexas.tacc.tapis.shared.utils.TapisGsonUtils;
import edu.utexas.tacc.tapis.shared.TapisConstants;
import edu.utexas.tacc.tapis.shared.exceptions.TapisException;
import edu.utexas.tacc.tapis.notifications.config.RuntimeParameters;
import edu.utexas.tacc.tapis.notifications.utils.LibUtils;
import edu.utexas.tacc.tapis.notifications.dao.NotificationsDao;
import edu.utexas.tacc.tapis.notifications.model.DeliveryMethod;
import edu.utexas.tacc.tapis.notifications.model.Event;
import edu.utexas.tacc.tapis.notifications.model.Notification;

/*
 * Callable for sending out a single notification generated by a bucket manager.
 * After finite number of attempts give up and add the notification to the recovery table.
 * Number of attempts determined by runtime setting TAPIS_NTF_DELIVERY_ATTEMPTS
 * Attempt interval determined by runtime setting TAPIS_NTF_DELIVERY_RETRY_INTERVAL
 */
public final class DeliveryTask implements Callable<Notification>
{
  /* ********************************************************************** */
  /*                               Constants                                */
  /* ********************************************************************** */
  // Tracing.
  private static final Logger log = LoggerFactory.getLogger(DeliveryTask.class);

  /* ********************************************************************** */
  /*                                Enums                                   */
  /* ********************************************************************** */

  /* ********************************************************************** */
  /*                                 Fields                                 */
  /* ********************************************************************** */

  private final NotificationsDao dao;
  private final Notification notification; // The notification to be processed
  private final String tenant;
  private final UUID uuid;
  private final int bucketNum; // Bucket that generated the notification
  private final DeliveryMethod deliveryMethod;
  /* ********************************************************************** */
  /*                             Constructors                               */
  /* ********************************************************************** */

  DeliveryTask(NotificationsDao dao1, Notification n1)
  {
    dao = dao1;
    notification = n1;
    tenant = n1.getTenant();
    bucketNum = n1.getBucketNum();
    deliveryMethod = n1.getDeliveryMethod();
    uuid = n1.getUuid();
  }

  /* ********************************************************************** */
  /*                             Public Methods                             */
  /* ********************************************************************** */

  /*
   * Main method for thread.start
   * Make multiple attempts to deliver the notification. Pause after each attempt.
   * Number of attempts and interval are based on runtime settings.
   */
  @Override
  public Notification call() throws TapisException
  {
    int bucketNum = notification.getBucketNum();
    DeliveryMethod deliveryMethod = notification.getDeliveryMethod();
    UUID uuid = notification.getUuid();

    Thread.currentThread().setName("ThreadDelivery-bucket-" + bucketNum + "-method-" + deliveryMethod);
    log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_START", bucketNum, Thread.currentThread().getId(), Thread.currentThread().getName()));

    // Get number of attempts and attempt interval from settings.
    int numAttempts = RuntimeParameters.getInstance().getNtfDeliveryMaxAttempts();
    long deliveryAttemptInterval = RuntimeParameters.getInstance().getNtfDeliveryRetryInterval() * 1000L;
    for (int i = 1; i < numAttempts; i++)
    {
      log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_ATTEMPT", bucketNum, uuid, i, deliveryMethod));
      try
      {
        // Attempt to make the delivery
        boolean delivered = deliverNotification(notification);
        // If delivered ok we are done. Perform any post-delivery steps and return
        if (delivered) return notificationDelivered();

        // Delivery failed, log a warning.
        log.warn(LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL1", bucketNum, uuid, i, deliveryMethod));
      }
      catch (Exception e)
      {
        log.warn(LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL2", bucketNum, uuid, i, deliveryMethod, e.getMessage()), e);
      }
      // Pause for configured interval before trying again
      try
      {
        log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY_ATTEMPT_PAUSE", bucketNum, uuid, i, deliveryAttemptInterval));
        Thread.sleep(deliveryAttemptInterval);
      }
      catch (InterruptedException e) {}
    }

    // Give up for now, log warning and add to recovery table
    String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_FAIL", bucketNum, notification.getUuid(),
                                 deliveryMethod.getDeliveryType(), deliveryMethod.getDeliveryAddress(), numAttempts);
    log.warn(msg);
    addNotificationToRecovery();
    return null;
  }

  // ====================================================================================
  //  Make the delivery methods public static so they can also be used by recovery task
  // ====================================================================================

  /*
   * Send out a notification
   */
  public static boolean deliverNotification(Notification notification)
  {
    int bucketNum = notification.getBucketNum();
    Event event = notification.getEvent();
    DeliveryMethod deliveryMethod =  notification.getDeliveryMethod();

    log.debug(LibUtils.getMsg("NTFLIB_DSP_DLVRY", bucketNum, notification.getUuid(), deliveryMethod.getDeliveryType(),
            deliveryMethod.getDeliveryAddress(), event.getSource(), event.getType(),
            event.getSubject(), event.getSeriesId(), event.getTime(), event.getUuid()));
    boolean deliveryStatus = false;
    try
    {
      switch (deliveryMethod.getDeliveryType())
      {
        case WEBHOOK -> deliveryStatus = deliverByWebhook(notification);
        case EMAIL -> deliveryStatus = deliverByEmail(notification);
      }
    }
    catch (IOException | URISyntaxException | InterruptedException e)
    {
      // TODO
      log.warn("Caught exception during notification delivery: " + e.getMessage(), e);
    }
    return deliveryStatus;
  }

  /*
   * Send out the notification via Webhook
   * TODO: Handle exceptions
   *
   * TODO:
   *   - Cache the client
   *   - set client timeout
   *   - special handling for https?
   *   - handle auth if provided?
   *   - other headers?
   *
   */
  public static boolean deliverByWebhook(Notification ntf)
          throws URISyntaxException, IOException, InterruptedException
  {
    boolean delivered = true;
    int bucketNum = ntf.getBucketNum();
    DeliveryMethod deliveryMethod =  ntf.getDeliveryMethod();
    // Body is the notification as json
    String notifJsonStr = TapisGsonUtils.getGson(true).toJson(ntf);

    //    //??????????????????
//    // test GET - works
//    URI uri2 = new URI("http://localhost:8080/v3/notifications/healthcheck");
//    // TODO/TBD: timeout is 10 seconds
//    Duration timeout2 = Duration.of(10, ChronoUnit.SECONDS);
//    HttpRequest request2 = HttpRequest.newBuilder().uri(uri2)
//            .header("Accept", "application/json")
//            .header("Content-Type", "application/json")
//            .timeout(timeout2).build();
//    HttpResponse<String> response2 = httpClient.send(request2, HttpResponse.BodyHandlers.ofString());
//    // ?????????????????

    // TODO/TBD: Get works but POST hangs? maybe grizzly issue?
//    // Post to the delivery address which should be a URL
//    URI uri = new URI(deliveryMethod.getDeliveryAddress());
//    BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(eventJsonStr);
//    // TODO/TBD: timeout is 10 seconds
//    Duration timeout = Duration.of(30, ChronoUnit.SECONDS);
//    HttpRequest request = HttpRequest.newBuilder().uri(uri)
//            .header("Accept", "application/json")
//            .header("Content-Type", "application/json")
////            .method("POST", bodyPublisher).timeout(timeout).build();
////            .POST(bodyPublisher).timeout(timeout).build();
//            .POST(HttpRequest.BodyPublishers.noBody()).timeout(timeout).build();
//    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
//    if (response.statusCode() == Status.OK.getStatusCode()) return true;

    OkHttpClient client = new OkHttpClient();
    RequestBody body = RequestBody.create(notifJsonStr, MediaType.parse("application/json"));
    Request.Builder requestBuilder = new Request.Builder().url(deliveryMethod.getDeliveryAddress()).post(body);
    Request request = requestBuilder.addHeader("User-Agent", "Tapis/%s".formatted(TapisConstants.API_VERSION)).build();
    Call call = client.newCall(request);
    Response response = call.execute();
    // If response status code is not 200 assume delivery failed.
    if (response.code() != Status.OK.getStatusCode())
    {
      log.error(LibUtils.getMsg("NTFLIB_DSP_DLVRY_WH_FAIL_ERR", bucketNum, ntf.getUuid(),
              deliveryMethod.getDeliveryType(), deliveryMethod.getDeliveryAddress(), response.code()));
      delivered = false;
    }
    return delivered;
  }

  /*
   * Send out the notification via email
   * TODO: Handle exceptions
   */
  public static boolean deliverByEmail(Notification ntf) throws IOException, InterruptedException
  {
    boolean delivered = true;
    int bucketNum = ntf.getBucketNum();
    DeliveryMethod deliveryMethod =  ntf.getDeliveryMethod();
    // Body is the notification as json
    String notifJsonStr = TapisGsonUtils.getGson(true).toJson(ntf);

    String eventType = ntf.getEvent().getType();
    String eventSubj = ntf.getEvent().getSubject();
    String mailSubj;
    if (StringUtils.isBlank(eventSubj))
      mailSubj = LibUtils.getMsg("NTFLIB_DSP_DLVRY_MAIL_SUBJ1", TapisConstants.API_VERSION, eventType);
    else
      mailSubj = LibUtils.getMsg("NTFLIB_DSP_DLVRY_MAIL_SUBJ2", TapisConstants.API_VERSION, eventType, eventSubj);
    String mailBody = notifJsonStr;
    String sendToAddress = deliveryMethod.getDeliveryAddress();
    String sendToName = deliveryMethod.getDeliveryAddress();
    RuntimeParameters runtime = RuntimeParameters.getInstance();
    try
    {
      EmailClient client = EmailClientFactory.getClient(runtime);
      client.send(sendToName, sendToAddress, mailSubj, mailBody, HTMLizer.htmlize(mailBody));
    } catch (TapisException e)
    {
      log.error(LibUtils.getMsg("NTFLIB_DSP_DLVRY_EM_FAIL_ERR", bucketNum, ntf.getUuid(),
                            deliveryMethod.getDeliveryType(), deliveryMethod.getDeliveryAddress(), e.getMessage(), e));
      delivered = false;
    }
    return delivered;
  }

  /* ********************************************************************** */
  /*                             Private Methods                            */
  /* ********************************************************************** */

  /*
   * Notification has been delivered. Remove it from the table.
   */
  private Notification notificationDelivered()
  {
    try { dao.deleteNotification(tenant, notification); }
    catch (TapisException e)
    {
      String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_DEL_ERR", bucketNum, uuid,
                             deliveryMethod.getDeliveryType(), deliveryMethod.getDeliveryAddress(), e.getMessage(), e);
      log.error(msg);
      return null;
    }
    return notification;
  }

  /*
   * Initial Notification delivery failed. Add it to the recovery table and delete it from notification table
   *  in a single transaction.
   */
  private void addNotificationToRecovery()
  {
    try
    {
      dao.deleteNotificationAndAddToRecovery(tenant, notification);
    }
    catch (TapisException e)
    {
      String msg = LibUtils.getMsg("NTFLIB_DSP_DLVRY_RCVR_ADD_ERR", bucketNum, notification.getUuid(),
                                   deliveryMethod.getDeliveryType(), deliveryMethod.getDeliveryAddress(),
                                   e.getMessage(), e);
      log.error(msg);
    }
  }
}