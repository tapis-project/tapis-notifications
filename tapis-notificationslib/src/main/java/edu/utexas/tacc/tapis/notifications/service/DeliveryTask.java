package edu.utexas.tacc.tapis.notifications.service;

import okhttp3.Call;
import okhttp3.MediaType;
import okhttp3.OkHttp;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.BodyPublisher;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpResponse;
import java.net.http.HttpResponse.BodyHandlers;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.Callable;
import javax.ws.rs.core.Response.Status;

import edu.utexas.tacc.tapis.notifications.dao.NotificationsDao;
import edu.utexas.tacc.tapis.notifications.model.DeliveryMethod;
import edu.utexas.tacc.tapis.notifications.model.Event;
import edu.utexas.tacc.tapis.notifications.model.Notification;

/*
 * Callable for sending out a single notification generated by a bucket manager.
 */
public final class DeliveryTask implements Callable<Notification>
{
  /* ********************************************************************** */
  /*                               Constants                                */
  /* ********************************************************************** */
  // Tracing.
  private static final Logger log = LoggerFactory.getLogger(DeliveryTask.class);

  /* ********************************************************************** */
  /*                                Enums                                   */
  /* ********************************************************************** */

  /* ********************************************************************** */
  /*                                 Fields                                 */
  /* ********************************************************************** */

  // Use HK2 to inject singletons TODO/TBD: can we inject it this way?
  @Inject
  private NotificationsDao dao;

  private final HttpClient httpClient = HttpClient.newHttpClient();

  private final Notification notification; // The notification to be processed
  private final int bucketNum; // Bucket that generated the notification
  private final DeliveryMethod deliveryMethod;

  /* ********************************************************************** */
  /*                             Constructors                               */
  /* ********************************************************************** */

  DeliveryTask(NotificationsDao dao1, Notification n1)
  {
    dao = dao1;
    notification = n1;
    bucketNum = n1.getBucketNum();
    deliveryMethod = n1.getDeliveryMethod();
  }
  
  /* ********************************************************************** */
  /*                             Public Methods                             */
  /* ********************************************************************** */

  /*
   * Main method for thread.start
   */
  @Override
  public Notification call()
  {
    log.info("**** Starting Delivery task");
    Thread.currentThread().setName("ThreadDelivery-bucket-"+ bucketNum + "-deliveryAddr-" + deliveryMethod.getDeliveryAddress());
    log.info("ThreadId: {} ThreadName: {}", Thread.currentThread().getId(), Thread.currentThread().getName());

    boolean delivered = false;
    log.info("**** Delivery task first attempt");
    try
    {
      delivered = deliverNotification();
    }
    catch (Exception e)
    {
      // TODO
      log.warn("First delivery attempt failed. Caught exception: " + e.getMessage(), e);
    }

    if (delivered)
    {
      // First attempt succeeded
      // TODO: What if we crash before removing notification?
      //       and what if dao call throws exception?
//      dao.deleteNotification(notification);
      return notification;
    }

    // Pause and then try one more time
    try {log.info("Sleep 15 seconds"); Thread.sleep(15000); } catch (InterruptedException e) {}
    log.info("**** First delivery attempt failed. Delivery task second attempt");
    try
    {
      deliverNotification();
    }
    catch (Exception e)
    {
      // TODO
      log.warn("Second delivery attempt failed. Caught exception: " + e.getMessage(), e);
      return null;
    }

    // Second attempt succeeded
    // TODO: What if we crash before removing notification?
    //       and what if dao call throws exception? return false? re-throw?
//      dao.deleteNotification(notification);
    return notification;
  }

  /* ********************************************************************** */
  /*                             Accessors                                  */
  /* ********************************************************************** */

  public int getBucketNum() { return bucketNum; }

  /* ********************************************************************** */
  /*                             Private Methods                            */
  /* ********************************************************************** */

  /*
   * TODO Send out the notification
   */
  private boolean deliverNotification()
  {
    Event event = notification.getEvent();
    log.info("Processing notification for event. Source: {} Type: {} Subject: {} SeriesId: {} Time: {} UUID {}",
             event.getSource(), event.getType(), event.getSubject(), event.getSeriesId(),
             event.getTime(), event.getUuid());
    log.info("Deliver notification. DeliveryType: {} DeliveryAddress: {}", deliveryMethod.getDeliveryType(),
             deliveryMethod.getDeliveryAddress());

    boolean deliveryStatus = false;
    try
    {
      switch (deliveryMethod.getDeliveryType())
      {
        case WEBHOOK -> deliveryStatus = deliverByWebhook();
        case EMAIL -> deliveryStatus = deliverByEmail();
      }
    }
    catch (IOException | URISyntaxException | InterruptedException e)
    {
      // TODO
      log.warn("Caught exception during notification delivery: " + e.getMessage(), e);
    }
    return deliveryStatus;
  }

  /*
   * TODO Send out the notification via Webhook
   *
   * TODO:
   *   - Cache the client
   *   - set client timeout
   *
   */
  private boolean deliverByWebhook() throws URISyntaxException, IOException, InterruptedException
  {
//    // Post to the delivery address which should be a URL
//    URI uri = new URI(deliveryMethod.getDeliveryAddress());
//    // Request body is the event as json
    String eventJsonStr = notification.getEvent().toJsonString();
//    HttpRequest.BodyPublisher bodyPublisher = BodyPublishers.ofString(eventJsonStr);
//    // TODO/TBD: timeout is 10 seconds
//    Duration timeout = Duration.of(10, ChronoUnit.SECONDS);
//    HttpRequest request = HttpRequest.newBuilder().uri(uri).header("Content-Type", "application/json")
//                                                  .POST(bodyPublisher).timeout(timeout).build();
//    HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());
//    if (response.statusCode() == Status.OK.getStatusCode()) return true;

    OkHttpClient client = new OkHttpClient();
    RequestBody body = RequestBody.create(MediaType.parse("application/json"), eventJsonStr);
    Request request = new Request.Builder().url(deliveryMethod.getDeliveryAddress()).post(body).build();
    Call call = client.newCall(request);
    Response response = call.execute();
    if (response.code() == Status.OK.getStatusCode()) return true;
    return false;
  }
  /*
   * TODO Send out the notification via email
   *
   */
  private boolean deliverByEmail() throws IOException, InterruptedException
  {
    return false;
  }
}